From da98eeb5e7ab4695c1d220454fe5a51cb3ea484e Mon Sep 17 00:00:00 2001
From: Jernej Skrabec <jernej.skrabec@siol.net>
Date: Tue, 22 Nov 2016 23:35:31 +0100
Subject: [PATCH 3/5] sunxi: video: Refactor and reorganize code. Still work to
 do.

Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
---
 arch/arm/include/asm/arch-sunxi/display2.h         | 145 +++++-----
 drivers/video/Makefile                             |   2 +-
 .../video/{sun8i_display.c => sunxi_display2.c}    | 305 +++++++++++----------
 include/configs/sunxi-common.h                     |   2 +-
 scripts/config_whitelist.txt                       |   2 +-
 5 files changed, 225 insertions(+), 231 deletions(-)
 rename drivers/video/{sun8i_display.c => sunxi_display2.c} (78%)

diff --git a/arch/arm/include/asm/arch-sunxi/display2.h b/arch/arm/include/asm/arch-sunxi/display2.h
index 755adeb64f..4867f63807 100644
--- a/arch/arm/include/asm/arch-sunxi/display2.h
+++ b/arch/arm/include/asm/arch-sunxi/display2.h
@@ -3,71 +3,65 @@
  *
  * (C) Copyright 2016 Jernej Skrabec <jernej.skrabec@siol.net>
  *
- * Based on work by:
+ * Based on Linux DRM driver defines:
  * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
  * Copyright (c) 2016 Allwinnertech Co., Ltd.
  * 
+ * Based on display.h:
+ * (C) Copyright 2014 Hans de Goede <hdegoede@redhat.com>
+ * 
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
-#ifndef _SUNXI_DISPLAY_H
-#define _SUNXI_DISPLAY_H
-
-struct sun8i_lcdc_reg {
-	u32 gctl;
-	u32 gint0;
-	u32 gint1;
-	u32 dum0[13];
-	u32 tcon0_ctl;				/* 0x40 */
-	u32 dum1[19];
-	u32 tcon1_ctl;				/* 0x90 */
-	u32 basic0;			/* XI/YI */
-	u32 basic1;			/* LS_XO/LS_YO */
-	u32 basic2;			/* XO/YO */
-	u32 basic3;			/* HT/HBP */
-	u32 basic4;			/* VT/VBP */
-	u32 basic5;			/* HSPW/VSPW */
-	u32 dum2;
-	u32 ps_sync;				/* 0xb0 */
-	u32 dum3[15];
-	u32 io_pol;				/* 0xf0 */
-	u32 io_tri;
-	u32 dum4[2];
-
-	u32 ceu_ctl;				/* 0x100 */
-	u32 dum5[3];
-	u32 ceu_rr;
-	u32 ceu_rg;
-	u32 ceu_rb;
-	u32 ceu_rc;
-	u32 ceu_gr;
-	u32 ceu_gg;
-	u32 ceu_gb;
-	u32 ceu_gc;
-	u32 ceu_br;
-	u32 ceu_bg;
-	u32 ceu_bb;
-	u32 ceu_bc;
-	u32 ceu_rv;
-	u32 ceu_gv;
-	u32 ceu_bv;
-	u32 dum6[45];
-
-	u32 mux_ctl;				/* 0x200 */
-	u32 dum7[63];
-
-	u32 fill_ctl;				/* 0x300 */
-	u32 fill_start0;
-	u32 fill_end0;
-	u32 fill_data0;
-};
+#ifndef _SUNXI_DISPLAY2_H
+#define _SUNXI_DISPLAY2_H
+
+struct sunxi_lcdc_reg {
+	u32 ctrl;			/* 0x00 */
+	u32 int0;			/* 0x04 */
+	u32 int1;			/* 0x08 */
+	u8 res0[0x04];			/* 0x0c */
+	u32 tcon0_frm_ctrl;		/* 0x10 */
+	u32 tcon0_frm_seed[6];		/* 0x14 */
+	u32 tcon0_frm_table[4];		/* 0x2c */
+	u8 res1[4];			/* 0x3c */
+	u32 tcon0_ctrl;			/* 0x40 */
+	u32 tcon0_dclk;			/* 0x44 */
+	u32 tcon0_timing_active;	/* 0x48 */
+	u32 tcon0_timing_h;		/* 0x4c */
+	u32 tcon0_timing_v;		/* 0x50 */
+	u32 tcon0_timing_sync;		/* 0x54 */
+	u32 tcon0_hv_intf;		/* 0x58 */
+	u8 res2[0x04];			/* 0x5c */
+	u32 tcon0_cpu_intf;		/* 0x60 */
+	u32 tcon0_cpu_wr_dat;		/* 0x64 */
+	u32 tcon0_cpu_rd_dat0;		/* 0x68 */
+	u32 tcon0_cpu_rd_dat1;		/* 0x6c */
+	u32 tcon0_ttl_timing0;		/* 0x70 */
+	u32 tcon0_ttl_timing1;		/* 0x74 */
+	u32 tcon0_ttl_timing2;		/* 0x78 */
+	u32 tcon0_ttl_timing3;		/* 0x7c */
+	u32 tcon0_ttl_timing4;		/* 0x80 */
+	u32 tcon0_lvds_intf;		/* 0x84 */
+	u32 tcon0_io_polarity;		/* 0x88 */
+	u32 tcon0_io_tristate;		/* 0x8c */
+	u32 tcon1_ctrl;			/* 0x90 */
+	u32 tcon1_timing_source;	/* 0x94 */
+	u32 tcon1_timing_scale;		/* 0x98 */
+	u32 tcon1_timing_out;		/* 0x9c */
+	u32 tcon1_timing_h;		/* 0xa0 */
+	u32 tcon1_timing_v;		/* 0xa4 */
+	u32 tcon1_timing_sync;		/* 0xa8 */
+	u8 res3[0x44];			/* 0xac */
+	u32 tcon1_io_polarity;		/* 0xf0 */
+	u32 tcon1_io_tristate;		/* 0xf4 */
+	u8 res4[0x108];			/* 0xf8 */
+	u32 mux_ctrl;			/* 0x200 */};
 
 /* global control */
 struct de_glb {
 	u32 ctl;
 #define		DE_MUX_GLB_CTL_rt_en BIT(0)
-#define		DE_MUX_GLB_CTL_finish_irq_en BIT(4)
-#define		DE_MUX_GLB_CTL_rtwb_port BIT(12)
 	u32 status;
 	u32 dbuff;
 	u32 size;
@@ -149,21 +143,26 @@ struct de_ui {
 	u32 ovl_size;			/* 88 */
 };
 
-#define HDMI_EDID_BLOCK_SIZE 			128
+struct sunxi_phy_hdmi_reg {
+	u32 pol;
+	u32 dum0[3];
+	u32 read_en;
+	u32 dum1[3];
+	u32 ctrl;
+	u32 unk1;
+	u32 unk2;
+	u32 pll;
+	u32 clk;
+	u32 unk3;
+	u32 status;
+};
 
 /*
  * HDMI register addresses
  */
-#define SUN8I_HDMI_PHY_CTRL_REG			(u32*)(SUNXI_HDMI_BASE + 0x10020)
-#define SUN8I_HDMI_PHY_UNK1_REG			(u32*)(SUNXI_HDMI_BASE + 0x10024)
-#define SUN8I_HDMI_PHY_UNK2_REG			(u32*)(SUNXI_HDMI_BASE + 0x10028)
-#define SUN8I_HDMI_PHY_PLL_REG			(u32*)(SUNXI_HDMI_BASE + 0x1002c)
-#define SUN8I_HDMI_PHY_CLK_REG			(u32*)(SUNXI_HDMI_BASE + 0x10030)
-#define SUN8I_HDMI_PHY_UNK3_REG			(u32*)(SUNXI_HDMI_BASE + 0x10034)
-#define SUN8I_HDMI_PHY_STATUS_REG		(u32*)(SUNXI_HDMI_BASE + 0x10038)
+#define SUN8I_HDMI_PHY_BASE			(u32*)(SUNXI_HDMI_BASE + 0x10000)
 
 #define SUN8I_HDMI_IH_I2CM_STAT0		(u32*)(SUNXI_HDMI_BASE + 0x0013)
-
 #define SUN8I_HDMI_I2CM_SLAVE			(u32*)(SUNXI_HDMI_BASE + 0x0EE0)
 #define SUN8I_HDMI_I2CM_ADDRESS			(u32*)(SUNXI_HDMI_BASE + 0x0EE1)
 #define SUN8I_HDMI_I2CM_DATAI			(u32*)(SUNXI_HDMI_BASE + 0x8EE1)
@@ -218,28 +217,10 @@ struct de_ui {
 /*
  * LCDC register constants.
  */
-#define SUN8I_TCON_GCTL_TCON_En			(1 << 31)
-#define SUN8I_TCON_GINT0_TCON1_Vb_Int_En	(1 << 30)
-#define SUN8I_TCON_GINT0_TCON1_Vb_Int_Flag	(1 << 14)
-#define SUN8I_TCON0_CTL_TCON_En			(1 << 31)
-#define SUN8I_TCON1_CTL_TCON_En			(1 << 31)
-#define SUN8I_TCON1_CTL_Interlace_En		(1 << 20)
-#define SUN8I_TCON1_CTL_Start_Delay_SHIFT	4
-/*#define SUN8I_TCON1_CTL_Start_Delay_MASK	GENMASK(8, 4)*/
-#define SUN8I_TCON1_IO_POL_IO0_inv		(1 << 24)
-#define SUN8I_TCON1_IO_POL_IO1_inv		(1 << 25)
-#define SUN8I_TCON1_IO_POL_IO2_inv		(1 << 26)
-#define SUN8I_TCON_CEU_CTL_ceu_en		(1 << 31)
-
 #define SUNXI_LCDC_X(x)				(((x) - 1) << 16)
 #define SUNXI_LCDC_Y(y)				(((y) - 1) << 0)
-#define SUNXI_LCDC_TCON_VSYNC_MASK		(1 << 24)
-#define SUNXI_LCDC_TCON_HSYNC_MASK		(1 << 25)
-#define SUNXI_LCDC_CTRL_IO_MAP_MASK		(1 << 0)
-#define SUNXI_LCDC_CTRL_IO_MAP_TCON0		(0 << 0)
-#define SUNXI_LCDC_CTRL_IO_MAP_TCON1		(1 << 0)
 #define SUNXI_LCDC_CTRL_TCON_ENABLE		(1 << 31)
-#define SUNXI_LCDC_TCON1_CTRL_SRC_BLUE		(1 << 1)
+#define SUNXI_LCDC_TCON0_CTRL_ENABLE		(1 << 31)
 #define SUNXI_LCDC_TCON1_CTRL_CLK_DELAY(n)	(((n) & 0x1f) << 4)
 #define SUNXI_LCDC_TCON1_CTRL_INTERLACE_ENABLE	(1 << 20)
 #define SUNXI_LCDC_TCON1_CTRL_ENABLE		(1 << 31)
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index d05b74514f..3097b82580 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -52,7 +52,7 @@ obj-$(CONFIG_VIDEO_OMAP3) += omap3_dss.o
 obj-$(CONFIG_VIDEO_SANDBOX_SDL) += sandbox_sdl.o
 obj-$(CONFIG_VIDEO_SM501) += sm501.o
 obj-$(CONFIG_VIDEO_SUNXI) += sunxi_display.o videomodes.o
-obj-$(CONFIG_VIDEO_SUNXI_H3) += sun8i_display.o videomodes.o
+obj-$(CONFIG_VIDEO_SUNXI2) += sunxi_display2.o videomodes.o
 obj-$(CONFIG_VIDEO_TEGRA20) += tegra.o
 obj-$(CONFIG_VIDEO_VCXK) += bus_vcxk.o
 obj-$(CONFIG_VIDEO_VESA) += vesa.o
diff --git a/drivers/video/sun8i_display.c b/drivers/video/sunxi_display2.c
similarity index 78%
rename from drivers/video/sun8i_display.c
rename to drivers/video/sunxi_display2.c
index e596e4c2c9..cecaeb48a1 100644
--- a/drivers/video/sun8i_display.c
+++ b/drivers/video/sunxi_display2.c
@@ -47,54 +47,60 @@ struct sunxi_display {
 
 #ifdef CONFIG_VIDEO_HDMI
 
-static void sun8i_hdmi_phy_init(void)
+static void sunxi_hdmi_phy_init(void)
 {
+	struct sunxi_phy_hdmi_reg * const phy =
+		(struct sunxi_phy_hdmi_reg *)SUN8I_HDMI_PHY_BASE;
 	unsigned long tmo;
 	u32 tmp;
 
-	writel(0, SUN8I_HDMI_PHY_CTRL_REG);
-	setbits_le32(SUN8I_HDMI_PHY_CTRL_REG, BIT(0));
+	/*
+	 * HDMI PHY settings are taken as-is from Allwinner BSP code.
+	 * There is no documentation.
+	 */
+	writel(0, &phy->ctrl);
+	setbits_le32(&phy->ctrl, BIT(0));
 	udelay(5);
-	setbits_le32(SUN8I_HDMI_PHY_CTRL_REG, BIT(16));
-	setbits_le32(SUN8I_HDMI_PHY_CTRL_REG, BIT(1));
+	setbits_le32(&phy->ctrl, BIT(16));
+	setbits_le32(&phy->ctrl, BIT(1));
 	udelay(10);
-	setbits_le32(SUN8I_HDMI_PHY_CTRL_REG, BIT(2));
+	setbits_le32(&phy->ctrl, BIT(2));
 	udelay(5);
-	setbits_le32(SUN8I_HDMI_PHY_CTRL_REG, BIT(3));
+	setbits_le32(&phy->ctrl, BIT(3));
 	udelay(40);
-	setbits_le32(SUN8I_HDMI_PHY_CTRL_REG, BIT(19));
+	setbits_le32(&phy->ctrl, BIT(19));
 	udelay(100);
-	setbits_le32(SUN8I_HDMI_PHY_CTRL_REG, BIT(18));
-	setbits_le32(SUN8I_HDMI_PHY_CTRL_REG, 7 << 4);
+	setbits_le32(&phy->ctrl, BIT(18));
+	setbits_le32(&phy->ctrl, 7 << 4);
 
-	/* Note that Allwinner code doesn't fail in case of timeout  */
+	/* Note that Allwinner code doesn't fail in case of timeout */
 	tmo = timer_get_us() + 2000;
-	while ((readl(SUN8I_HDMI_PHY_STATUS_REG) & 0x80) == 0) {
+	while ((readl(&phy->status) & 0x80) == 0) {
 		if (timer_get_us() > tmo) {
-			printf("Warning: HDMI phy init timeout!\n");
+			printf("Warning: HDMI PHY init timeout!\n");
 			break;
 		}
 	}
 
-	setbits_le32(SUN8I_HDMI_PHY_CTRL_REG, 0xf << 8);
-	setbits_le32(SUN8I_HDMI_PHY_CTRL_REG, BIT(7));
+	setbits_le32(&phy->ctrl, 0xf << 8);
+	setbits_le32(&phy->ctrl, BIT(7));
 
-	writel(0x39dc5040, SUN8I_HDMI_PHY_PLL_REG);
-	writel(0x80084343, SUN8I_HDMI_PHY_CLK_REG);
+	writel(0x39dc5040, &phy->pll);
+	writel(0x80084343, &phy->clk);
 	udelay(10000);
-	writel(1, SUN8I_HDMI_PHY_UNK3_REG);
-	setbits_le32(SUN8I_HDMI_PHY_PLL_REG, BIT(25));
+	writel(1, &phy->unk3);
+	setbits_le32(&phy->pll, BIT(25));
 	udelay(100000);
-	tmp = (readl(SUN8I_HDMI_PHY_STATUS_REG) & 0x1f800) >> 11;
-	setbits_le32(SUN8I_HDMI_PHY_PLL_REG, BIT(31) | BIT(30));
-	setbits_le32(SUN8I_HDMI_PHY_PLL_REG, tmp);
-	writel(0x01FF0F7F, SUN8I_HDMI_PHY_CTRL_REG);
-	writel(0x80639000, SUN8I_HDMI_PHY_UNK1_REG);
-	writel(0x0F81C405, SUN8I_HDMI_PHY_UNK2_REG);
+	tmp = (readl(&phy->status) & 0x1f800) >> 11;
+	setbits_le32(&phy->pll, BIT(31) | BIT(30));
+	setbits_le32(&phy->pll, tmp);
+	writel(0x01FF0F7F, &phy->ctrl);
+	writel(0x80639000, &phy->unk1);
+	writel(0x0F81C405, &phy->unk2);
 
 	/* enable read access to HDMI controller*/
-	writel(0x54524545, SUNXI_HDMI_BASE + 0x10010);
-	
+	writel(0x54524545, &phy->read_en);
+
 	writeb(0x00, SUNXI_HDMI_BASE + 0x8080);
 
 	udelay(1);
@@ -129,10 +135,12 @@ static void sun8i_hdmi_phy_init(void)
 	writeb(0xff, SUNXI_HDMI_BASE + 0x8013);
 }
 
-static int sun8i_hdmi_hpd_detect(int hpd_delay)
+static int sunxi_hdmi_hpd_detect(int hpd_delay)
 {
 	struct sunxi_ccm_reg * const ccm =
 		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	struct sunxi_phy_hdmi_reg * const phy =
+		(struct sunxi_phy_hdmi_reg *)SUN8I_HDMI_PHY_BASE;
 	unsigned long tmo = timer_get_us() + hpd_delay * 1000;
 	int status = 0;
 
@@ -152,10 +160,10 @@ static int sun8i_hdmi_hpd_detect(int hpd_delay)
 	/* Clock on */
 	setbits_le32(&ccm->hdmi_clk_cfg, CCM_HDMI_CTRL_GATE);
 
-	sun8i_hdmi_phy_init();
+	sunxi_hdmi_phy_init();
 
 	while (timer_get_us() < tmo) {
-		if (readl(SUN8I_HDMI_PHY_STATUS_REG) & SUNXI_HDMI_HPD_DETECT) {
+		if (readl(&phy->status) & SUNXI_HDMI_HPD_DETECT) {
 			status = 1;
 			break;
 		}
@@ -168,8 +176,10 @@ static void sunxi_hdmi_shutdown(void)
 {
 	struct sunxi_ccm_reg * const ccm =
 		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	struct sunxi_phy_hdmi_reg * const phy =
+		(struct sunxi_phy_hdmi_reg *)SUN8I_HDMI_PHY_BASE;
 
-	writel(0, SUN8I_HDMI_PHY_CTRL_REG);
+	writel(0, &phy->ctrl);
 	clrbits_le32(&ccm->hdmi_clk_cfg, CCM_HDMI_CTRL_GATE);
 	clrbits_le32(&ccm->hdmi_slow_clk_cfg, CCM_HDMI_SLOW_CTRL_DDC_GATE);
 	clrbits_le32(&ccm->ahb_gate1, 1 << AHB_GATE_OFFSET_HDMI);
@@ -178,7 +188,7 @@ static void sunxi_hdmi_shutdown(void)
 	clock_set_pll3(0);
 }
 
-static int sun8i_hdmi_ddc_wait_i2c_done(int msec)
+static int sunxi_hdmi_ddc_wait_i2c_done(int msec)
 {
 	u32 val;
 	ulong start;
@@ -212,11 +222,11 @@ static int sunxi_hdmi_ddc_read(int block, u8 *buf)
 	while (trytime--) {
 		edid_read_err = 0;
 
-		for (n = 0; n < HDMI_EDID_BLOCK_SIZE; n++) {
+		for (n = 0; n < 128; n++) {
 			writeb(shift + n, SUN8I_HDMI_I2CM_ADDRESS);
 			writeb(op, SUN8I_HDMI_I2CM_OPERATION);
 
-			if (sun8i_hdmi_ddc_wait_i2c_done(10)) {
+			if (sunxi_hdmi_ddc_wait_i2c_done(10)) {
 				edid_read_err = 1;
 				break;
 			}
@@ -336,7 +346,7 @@ static void sunxi_composer_init(void)
 		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
 
 	clock_set_pll10(432000000);
-	
+
 	/* Set DE parent to pll10 */
 	clrsetbits_le32(&ccm->de_clk_cfg, CCM_DE_CTRL_PLL_MASK,
 			CCM_DE_CTRL_PLL10);
@@ -381,8 +391,8 @@ static void sunxi_composer_mode_set(const struct ctfb_res_modes *mode,
 		memset(chan, 0, channel == 0 ?
 			sizeof(struct de_vi) : sizeof(struct de_ui));
 	}
-
 	memset(de_bld_regs, 0, 0x44);
+	
 	writel(0x00000101, &de_bld_regs->fcolor_ctl);
 
 	writel(1, &de_bld_regs->route);
@@ -402,7 +412,8 @@ static void sunxi_composer_mode_set(const struct ctfb_res_modes *mode,
 		writel(0xff000000, &de_bld_regs->attr[i].fcolor);
 		writel(size, &de_bld_regs->attr[i].insize);
 	}
-	
+
+	/* Disable all other units */
 	writel(0, DE_MUX0_BASE + DE_MUX_VSU_REGS);
 	writel(0, DE_MUX0_BASE + DE_MUX_GSU1_REGS);
 	writel(0, DE_MUX0_BASE + DE_MUX_GSU2_REGS);
@@ -443,13 +454,18 @@ static void sunxi_lcdc_pll_set(int dotclock, int *clk_div)
 	int value, n, m, x = 0, diff;
 	int best_n = 0, best_m = 0, best_diff = 0x0FFFFFFF;
 
+	/*
+	 * Due to unknown registers in HDMI PHY, we know correct settings
+	 * only for following four PHY dividers. Select one based on
+	 * clock speed.
+	 */
 	if (dotclock <= 27000)
 		x = 11;
 	else if (dotclock <= 74250)
 		x = 4;
 	else if (dotclock <= 148500)
 		x = 2;
-	else if (dotclock <= 297000)
+	else
 		x = 1;
 
 	/*
@@ -472,7 +488,7 @@ static void sunxi_lcdc_pll_set(int dotclock, int *clk_div)
 	}
 
 	clock_set_pll3_factors(best_m, best_n);
-	printf("dotclock: %dkHz = %dkHz: (24MHz * %d) / %d / %d\n",
+	debug("dotclock: %dkHz = %dkHz: (24MHz * %d) / %d / %d\n",
 		dotclock, (clock_get_pll3() / 1000) / x,
 		best_n, best_m, x);
 
@@ -486,8 +502,8 @@ static void sunxi_lcdc_init(void)
 {
 	struct sunxi_ccm_reg * const ccm =
 		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
-	struct sun8i_lcdc_reg * const lcdc =
-		(struct sun8i_lcdc_reg *)SUNXI_LCD0_BASE;
+	struct sunxi_lcdc_reg * const lcdc =
+		(struct sunxi_lcdc_reg *)SUNXI_LCD0_BASE;
 
 	/* Reset off */
 	setbits_le32(&ccm->ahb_reset1_cfg, 1 << AHB_RESET_OFFSET_TCON0);
@@ -497,78 +513,71 @@ static void sunxi_lcdc_init(void)
 	setbits_le32(&ccm->tcon0_clk_cfg, CCM_TCON0_CTRL_GATE);
 
 	/* Init lcdc */
-	clrbits_le32(&lcdc->tcon0_ctl, SUN8I_TCON0_CTL_TCON_En); /* Disable tcon0 */
-	clrbits_le32(&lcdc->gctl, SUN8I_TCON_GCTL_TCON_En); /* Disable tcon globally */
-	writel(0, &lcdc->gint0); /* Disable all interrupts */
+	writel(0, &lcdc->ctrl); /* Disable tcon */
+	writel(0, &lcdc->int0); /* Disable all interrupts */
 
 	/* Set all io lines to tristate */
-	writel(0x0fffffff, &lcdc->io_tri);
+	writel(0x0fffffff, &lcdc->tcon1_io_tristate);
 }
 
 static void sunxi_lcdc_enable(void)
 {
-	struct sun8i_lcdc_reg * const lcdc =
-		(struct sun8i_lcdc_reg *)SUNXI_LCD0_BASE;
+	struct sunxi_lcdc_reg * const lcdc =
+		(struct sunxi_lcdc_reg *)SUNXI_LCD0_BASE;
 
-	setbits_le32(&lcdc->gctl, SUN8I_TCON_GCTL_TCON_En);
+	setbits_le32(&lcdc->ctrl, SUNXI_LCDC_CTRL_TCON_ENABLE);
 }
 
-static int sunxi_lcdc_get_clk_delay(const struct ctfb_res_modes *mode, int tcon)
+static int sunxi_lcdc_get_clk_delay(const struct ctfb_res_modes *mode)
 {
 	int delay;
 
 	delay = mode->lower_margin + mode->vsync_len + mode->upper_margin;
 	if (mode->vmode == FB_VMODE_INTERLACED)
 		delay /= 2;
-	if (tcon == 1)
-		delay -= 2;
+	delay -= 2;
 
 	return (delay > 31) ? 31 : delay;
 }
 
 #if defined CONFIG_VIDEO_HDMI
-static void sunxi_lcdc_tcon0_mode_set(const struct ctfb_res_modes *mode,
+static void sunxi_lcdc_tcon1_mode_set(const struct ctfb_res_modes *mode,
 				      int *clk_div)
 {
-	struct sun8i_lcdc_reg * const lcdc =
-		(struct sun8i_lcdc_reg *)SUNXI_LCD0_BASE;
+	struct sunxi_lcdc_reg * const lcdc =
+		(struct sunxi_lcdc_reg *)SUNXI_LCD0_BASE;
 	int bp, clk_delay, total, yres;
 
-	setbits_le32(&lcdc->gctl, SUN8I_TCON_GCTL_TCON_En);
-
-	clk_delay = sunxi_lcdc_get_clk_delay(mode, 1);
+	clk_delay = sunxi_lcdc_get_clk_delay(mode);
 	writel(SUNXI_LCDC_TCON1_CTRL_ENABLE |
 	       ((mode->vmode == FB_VMODE_INTERLACED) ?
 			SUNXI_LCDC_TCON1_CTRL_INTERLACE_ENABLE : 0) |
-	       SUNXI_LCDC_TCON1_CTRL_CLK_DELAY(clk_delay), &lcdc->tcon1_ctl);
+	       SUNXI_LCDC_TCON1_CTRL_CLK_DELAY(clk_delay), &lcdc->tcon1_ctrl);
 
 	yres = mode->yres;
 	if (mode->vmode == FB_VMODE_INTERLACED)
 		yres /= 2;
 	writel(SUNXI_LCDC_X(mode->xres) | SUNXI_LCDC_Y(yres),
-	       &lcdc->basic0);
+	       &lcdc->tcon1_timing_source);
 	writel(SUNXI_LCDC_X(mode->xres) | SUNXI_LCDC_Y(yres),
-	       &lcdc->basic1);
+	       &lcdc->tcon1_timing_scale);
 	writel(SUNXI_LCDC_X(mode->xres) | SUNXI_LCDC_Y(yres),
-	       &lcdc->basic2);
+	       &lcdc->tcon1_timing_out);
 
 	bp = mode->hsync_len + mode->left_margin;
 	total = mode->xres + mode->right_margin + bp;
 	writel(SUNXI_LCDC_TCON1_TIMING_H_TOTAL(total) |
-	       SUNXI_LCDC_TCON1_TIMING_H_BP(bp), &lcdc->basic3);
+	       SUNXI_LCDC_TCON1_TIMING_H_BP(bp), &lcdc->tcon1_timing_h);
 
 	bp = mode->vsync_len + mode->upper_margin;
 	total = mode->yres + mode->lower_margin + bp;
 	if (mode->vmode == FB_VMODE_NONINTERLACED)
 		total *= 2;
 	writel(SUNXI_LCDC_TCON1_TIMING_V_TOTAL(total) |
-	       SUNXI_LCDC_TCON1_TIMING_V_BP(bp), &lcdc->basic4);
+	       SUNXI_LCDC_TCON1_TIMING_V_BP(bp), &lcdc->tcon1_timing_v);
 
 	writel(SUNXI_LCDC_X(mode->hsync_len) | SUNXI_LCDC_Y(mode->vsync_len),
-	       &lcdc->basic5);
-
-	writel(0, &lcdc->ceu_ctl);
-	writel(0, &lcdc->fill_ctl);
+	       &lcdc->tcon1_timing_sync);
 
 	sunxi_lcdc_pll_set(mode->pixclock_khz, clk_div);
 }
@@ -596,90 +605,90 @@ static void sunxi_hdmi_setup_info_frames(const struct ctfb_res_modes *mode)
 	writeb(0x88, SUNXI_HDMI_BASE + 0xC045);
 }
 
-static int hdmi_phy_set(u32 divider)
+static void sunxi_hdmi_phy_set(u32 divider)
 {
+	struct sunxi_phy_hdmi_reg * const phy =
+		(struct sunxi_phy_hdmi_reg *)SUN8I_HDMI_PHY_BASE;
 	u32 tmp;
 
-	switch(divider)
-	{
-		case 1:
-			writel(0x30dc5fc0, SUN8I_HDMI_PHY_PLL_REG);
-			writel(0x800863C0, SUN8I_HDMI_PHY_CLK_REG);
-			mdelay(10);
-			writel(0x00000001, SUN8I_HDMI_PHY_UNK3_REG);
-			setbits_le32(SUN8I_HDMI_PHY_PLL_REG, BIT(25));
-			mdelay(200);
-			tmp = (readl(SUN8I_HDMI_PHY_STATUS_REG) & 0x1f800) >> 11;
-			setbits_le32(SUN8I_HDMI_PHY_PLL_REG, BIT(31) | BIT(30));
-			if (tmp < 0x3d)
-				setbits_le32(SUN8I_HDMI_PHY_PLL_REG, tmp + 2);
-			else
-				setbits_le32(SUN8I_HDMI_PHY_PLL_REG, 0x3f);
-			mdelay(100);
-			writel(0x01FFFF7F, SUN8I_HDMI_PHY_CTRL_REG);
-			writel(0x8063b000, SUN8I_HDMI_PHY_UNK1_REG);
-			writel(0x0F8246B5, SUN8I_HDMI_PHY_UNK2_REG);
-			break;
-		case 2:
-			writel(0x39dc5040, SUN8I_HDMI_PHY_PLL_REG);
-			writel(0x80084381, SUN8I_HDMI_PHY_CLK_REG);
-			mdelay(10);
-			writel(0x00000001, SUN8I_HDMI_PHY_UNK3_REG);
-			setbits_le32(SUN8I_HDMI_PHY_PLL_REG, BIT(25));
-			mdelay(100);
-			tmp = (readl(SUN8I_HDMI_PHY_STATUS_REG) & 0x1f800) >> 11;
-			setbits_le32(SUN8I_HDMI_PHY_PLL_REG, BIT(31) | BIT(30));
-			setbits_le32(SUN8I_HDMI_PHY_PLL_REG, tmp);
-			writel(0x01FFFF7F, SUN8I_HDMI_PHY_CTRL_REG);
-			writel(0x8063a800, SUN8I_HDMI_PHY_UNK1_REG);
-			writel(0x0F81C485, SUN8I_HDMI_PHY_UNK2_REG);
-			break;
-		case 4:
-			writel(0x39dc5040, SUN8I_HDMI_PHY_PLL_REG);
-			writel(0x80084343, SUN8I_HDMI_PHY_CLK_REG);
-			mdelay(10);
-			writel(0x00000001, SUN8I_HDMI_PHY_UNK3_REG);
-			setbits_le32(SUN8I_HDMI_PHY_PLL_REG, BIT(25));
-			mdelay(100);
-			tmp = (readl(SUN8I_HDMI_PHY_STATUS_REG) & 0x1f800) >> 11;
-			setbits_le32(SUN8I_HDMI_PHY_PLL_REG, BIT(31) | BIT(30));
-			setbits_le32(SUN8I_HDMI_PHY_PLL_REG, tmp);
-			writel(0x01FFFF7F, SUN8I_HDMI_PHY_CTRL_REG);
-			writel(0x8063b000, SUN8I_HDMI_PHY_UNK1_REG);
-			writel(0x0F81C405, SUN8I_HDMI_PHY_UNK2_REG);
-			break;
-		case 11:
-			writel(0x39dc5040, SUN8I_HDMI_PHY_PLL_REG);
-			writel(0x8008430a, SUN8I_HDMI_PHY_CLK_REG);
-			mdelay(10);
-			writel(0x00000001, SUN8I_HDMI_PHY_UNK3_REG);
-			setbits_le32(SUN8I_HDMI_PHY_PLL_REG, BIT(25));
-			mdelay(100);
-			tmp = (readl(SUN8I_HDMI_PHY_STATUS_REG) & 0x1f800) >> 11;
-			setbits_le32(SUN8I_HDMI_PHY_PLL_REG, BIT(31) | BIT(30));
-			setbits_le32(SUN8I_HDMI_PHY_PLL_REG, tmp);
-			writel(0x01FFFF7F, SUN8I_HDMI_PHY_CTRL_REG);
-			writel(0x8063b000, SUN8I_HDMI_PHY_UNK1_REG);
-			writel(0x0F81C405, SUN8I_HDMI_PHY_UNK2_REG);
-			break;
-		default:
-			return -1;
+	/* 
+	 * Unfortunatelly, we don't know much about those magic
+	 * numbers. They are taken from Allwinner BSP driver.
+	 */
+	switch(divider) {
+	case 1:
+		writel(0x30dc5fc0, &phy->pll);
+		writel(0x800863C0, &phy->clk);
+		mdelay(10);
+		writel(0x00000001, &phy->unk3);
+		setbits_le32(&phy->pll, BIT(25));
+		mdelay(200);
+		tmp = (readl(&phy->status) & 0x1f800) >> 11;
+		setbits_le32(&phy->pll, BIT(31) | BIT(30));
+		if (tmp < 0x3d)
+			setbits_le32(&phy->pll, tmp + 2);
+		else
+			setbits_le32(&phy->pll, 0x3f);
+		mdelay(100);
+		writel(0x01FFFF7F, &phy->ctrl);
+		writel(0x8063b000, &phy->unk1);
+		writel(0x0F8246B5, &phy->unk2);
+		break;
+	case 2:
+		writel(0x39dc5040, &phy->pll);
+		writel(0x80084381, &phy->clk);
+		mdelay(10);
+		writel(0x00000001, &phy->unk3);
+		setbits_le32(&phy->pll, BIT(25));
+		mdelay(100);
+		tmp = (readl(&phy->status) & 0x1f800) >> 11;
+		setbits_le32(&phy->pll, BIT(31) | BIT(30));
+		setbits_le32(&phy->pll, tmp);
+		writel(0x01FFFF7F, &phy->ctrl);
+		writel(0x8063a800, &phy->unk1);
+		writel(0x0F81C485, &phy->unk2);
+		break;
+	case 4:
+		writel(0x39dc5040, &phy->pll);
+		writel(0x80084343, &phy->clk);
+		mdelay(10);
+		writel(0x00000001, &phy->unk3);
+		setbits_le32(&phy->pll, BIT(25));
+		mdelay(100);
+		tmp = (readl(&phy->status) & 0x1f800) >> 11;
+		setbits_le32(&phy->pll, BIT(31) | BIT(30));
+		setbits_le32(&phy->pll, tmp);
+		writel(0x01FFFF7F, &phy->ctrl);
+		writel(0x8063b000, &phy->unk1);
+		writel(0x0F81C405, &phy->unk2);
+		break;
+	case 11:
+		writel(0x39dc5040, &phy->pll);
+		writel(0x8008430a, &phy->clk);
+		mdelay(10);
+		writel(0x00000001, &phy->unk3);
+		setbits_le32(&phy->pll, BIT(25));
+		mdelay(100);
+		tmp = (readl(&phy->status) & 0x1f800) >> 11;
+		setbits_le32(&phy->pll, BIT(31) | BIT(30));
+		setbits_le32(&phy->pll, tmp);
+		writel(0x01FFFF7F, &phy->ctrl);
+		writel(0x8063b000, &phy->unk1);
+		writel(0x0F81C405, &phy->unk2);
+		break;
 	}
-
-	return 0;
 }
 
 static void sunxi_hdmi_mode_set(const struct ctfb_res_modes *mode,
 				int clk_div)
 {
+	struct sunxi_phy_hdmi_reg * const phy =
+		(struct sunxi_phy_hdmi_reg *)SUN8I_HDMI_PHY_BASE;
 	u8 invidconf, v_blanking;
 	u32 h_blanking;
 
-	if(hdmi_phy_set(clk_div) != 0) {
-		printf("HDMI divider is invalid!\n");
-		return;
-	}
-	
+	sunxi_hdmi_phy_set(clk_div);
+
 	invidconf = 0;
 	if(mode->vmode & FB_VMODE_INTERLACED)
 		invidconf |= 0x01;
@@ -692,7 +701,8 @@ static void sunxi_hdmi_mode_set(const struct ctfb_res_modes *mode,
 	v_blanking = mode->upper_margin + mode->lower_margin + mode->vsync_len;
 
 	writeb(invidconf | 0x10, SUNXI_HDMI_BASE + 0x0040);
-	writeb(((invidconf < 96) ? 0x03 : 0x00), SUNXI_HDMI_BASE + 0x10001);
+	if (invidconf < 96)
+		setbits_le32(&phy->pol, 0x300);
 
 	writeb(mode->xres >> 8, SUNXI_HDMI_BASE + 0x8040);
 	writeb(mode->xres, SUNXI_HDMI_BASE + 0x0041);
@@ -740,7 +750,10 @@ static void sunxi_hdmi_mode_set(const struct ctfb_res_modes *mode,
 
 static void sunxi_hdmi_enable(void)
 {
-	setbits_le32(SUN8I_HDMI_PHY_CTRL_REG, 0xf << 12);
+	struct sunxi_phy_hdmi_reg * const phy =
+		(struct sunxi_phy_hdmi_reg *)SUN8I_HDMI_PHY_BASE;
+
+	setbits_le32(&phy->ctrl, 0xf << 12);
 	printf("hdmi enabled\n");
 }
 
@@ -764,7 +777,7 @@ static void sunxi_mode_set(const struct ctfb_res_modes *mode,
 	case sunxi_monitor_hdmi:
 #ifdef CONFIG_VIDEO_HDMI
 		sunxi_composer_mode_set(mode, address);
-		sunxi_lcdc_tcon0_mode_set(mode, &clk_div);
+		sunxi_lcdc_tcon1_mode_set(mode, &clk_div);
 		sunxi_hdmi_mode_set(mode, clk_div);
 		sunxi_composer_enable();
 		sunxi_lcdc_enable();
@@ -777,9 +790,9 @@ static void sunxi_mode_set(const struct ctfb_res_modes *mode,
 static const char *sunxi_get_mon_desc(enum sunxi_monitor monitor)
 {
 	switch (monitor) {
-	case sunxi_monitor_none:		return "none";
-	case sunxi_monitor_dvi:			return "dvi";
-	case sunxi_monitor_hdmi:		return "hdmi";
+	case sunxi_monitor_none:	return "none";
+	case sunxi_monitor_dvi:		return "dvi";
+	case sunxi_monitor_hdmi:	return "hdmi";
 	}
 	return NULL; /* never reached */
 }
@@ -848,7 +861,7 @@ void *video_hw_init(void)
 	if (sunxi_display.monitor == sunxi_monitor_dvi ||
 	    sunxi_display.monitor == sunxi_monitor_hdmi) {
 		/* Always call hdp_detect, as it also enables clocks, etc. */
-		ret = sun8i_hdmi_hpd_detect(hpd_delay);
+		ret = sunxi_hdmi_hpd_detect(hpd_delay);
 		if (ret) {
 			printf("HDMI connected: ");
 			if (edid && sunxi_hdmi_edid_get_mode(&custom) == 0)
diff --git a/include/configs/sunxi-common.h b/include/configs/sunxi-common.h
index f35c15d998..7bf52478f1 100644
--- a/include/configs/sunxi-common.h
+++ b/include/configs/sunxi-common.h
@@ -289,7 +289,7 @@ extern int soft_i2c_gpio_scl;
 
 #define CONFIG_VIDEO_SUNXI
 #else
-#define CONFIG_VIDEO_SUNXI_H3
+#define CONFIG_VIDEO_SUNXI2
 #endif
 
 #define CONFIG_VIDEO_LOGO
diff --git a/scripts/config_whitelist.txt b/scripts/config_whitelist.txt
index 5d5fae8c0d..e466213c6c 100644
--- a/scripts/config_whitelist.txt
+++ b/scripts/config_whitelist.txt
@@ -6852,7 +6852,7 @@ CONFIG_VIDEO_SM501_8BPP
 CONFIG_VIDEO_SM501_PCI
 CONFIG_VIDEO_STD_TIMINGS
 CONFIG_VIDEO_SUNXI
-CONFIG_VIDEO_SUNXI_H3
+CONFIG_VIDEO_SUNXI2
 CONFIG_VIDEO_VCXK
 CONFIG_VID_FLS_ENV
 CONFIG_VM86
-- 
2.11.0

